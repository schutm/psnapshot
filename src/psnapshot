#!/bin/sh

set -o nounset
set -f

PSNAPSHOT_VERSION=0.9.0

PSNAPSHOT_FALSE=1
PSNAPSHOT_TRUE=0

PSNAPSHOT_BAIL=1
PSNAPSHOT_SUCCESS=0

# Bails out after printing an error message.
#
# Args:
#   message: string: Message to print before bailing out. [optional]
#   any additional arguments are ignored. There is no logic in bailing
#   if the invocation of bail() is incorrect.
# Returns:
#   Never returns.
bail() {
    printf "${1-Error occurred, bailing out}\n" >&2
    exit $PSNAPSHOT_BAIL
}

# Quits the script with a success code.
#
# Args:
#   None.
# Returns:
#   Never returns.
quit() {
    exit $PSNAPSHOT_SUCCESS
}

# Checks if a value exsists in a list.
#
# Args:
#   needle: string/integer: The searched value.
#   haystack: string/integer: The list to search in. [optional]
# Returns:
#   integer: success (TRUE/FALSE constant).
# Bails:
#   Unexpected number of arguments.
in_list() {
    [ $# -ge 1 ] || \
        bail "in_list expects at least 1 arguments; $# given"

    needle=$1
    shift

    for x in $@; do
        if [ $needle -eq $x ]; then
            unset x needle
            return $PSNAPSHOT_TRUE
        fi
    done

    unset x needle
    return $PSNAPSHOT_FALSE
}

# Create a scalar keyword for the Domain Specific Language. <keyword>
# setter is created. The value is stored in _<keyword>. The newly created
# function can be with 1 argument to set the new value.
#
# Args:
#   keyword: string: Keyword used in the DSL.
#   value: string/integer: The default value to return.
# Returns:
#   integer: success (TRUE/FALSE constant).
# Bails:
#   Unexpected number of arguments.
# Side effects:
#   Variable _<keyword> is set.
#   Function <keyword> is defined.
create_scalar_dsl() {
    [ $# -eq 2 ] || \
        bail "create_scalar_dsl expects 2 arguments; $# given"

    eval "_$1=\"$2\";                                             \
           $1() {                                                  \
               [ \$# -eq 1 ] ||                                    \
                   bail \"$1 expects 1 argument; \$# given\";      \
                                                                   \
               _$1=\"\$1\";                                        \
           }"
}

# Create the 'cmd' keywords for the Domain Specific Language.
# cmd_<keyword>, cmd_<keyword>_args and cmd_<keyword>verbose_arg setters
# are created. The values are stored in _cmd_<keyword>, _cmd_<keyword>_args
# and _cmd_<keyword>verbose_arg. The newly created functions can be invoked
# with 1 argument to set the new value.
#
# Args:
#   keyword: string: Keyword used in the DSL.
#   command: string: Shell command to invoke. cmd_<keyword> function
#   args: string: Arguments to use. cmd_<keyword>_args function. [optional]
#   verbose_arg: string: Argument to use to enable commands verbose mode
#                        cmd_<keyword>_verbose_arg function. [optional]
# Returns:
#   integer: success (TRUE/FALSE constant).
# Bails:
#   Unexpected number of arguments.
# Side effects:
#   Variables _<keyword>, _<keyword>_args and _<keyword>_verbose_arg are
#   set.
#   Functions cmd_<keyword>, cmd_<keyword>_args and
#   cmd_<keyword>_verbose_arg are defined.
create_cmd_dsl() {
    [ $# -ge 2 ] && [ $# -le 4 ] || \
        bail "create_cmd_dsl expects 2 to 4 arguments; $# given"

    # Get the dsl name.
    cmd_dsl=${1-}
    shift

    # Create the cmd_<cmd>, cmd_<cmd>_args and cmd_<cmd>verbose_arg
    # getters and setters.
    for postfix in '' args verbose_arg; do
        cmd=_${cmd_dsl}${postfix:+_$postfix}
        create_scalar_dsl "cmd${cmd}" "${1-}"
        shift
    done

    unset cmd postfix cmd_dsl
}

# Create an array keyword for the Domain Specific Language. <keyword>
# setter is created. The array is stored in _<keyword>. The newly created
# function can be invoked with the specified number of arguments to add
# to the array. Missing arguments will be added empty ('').
#
# Args:
#   keyword: string: Keyword used in the DSL.
#   args: integer[s]: The accepted number of arguments given at once.
#                     These should be order ascending.
# Returns:
#   integer: success (TRUE/FALSE constant).
# Bails:
#   Unexpected number of arguments.
# Side effects:
#   Variable _<keyword> is set.
#   Function <keyword> is defined.
create_array_dsl() {
    [ $# -ge 2 ] || \
        bail "create_array_dsl expects at least 2 arguments; $# given"

    fn=$1
    shift
    args=$(eval "echo \$$#")
    eval "$fn() {               \
               in_list \$# $@ || {                                     \
                   args=\"\$#\";                                       \
                   set -- $@;                                          \
                   msg=\"$fn expects \";                               \
                   while [ \$# -gt 1 ]; do                             \
                       case \$# in                                     \
                           2) msg=\"\$msg\$1 or \";;                   \
                           *) msg=\"\$msg\$1, \";;                     \
                       esac;                                           \
                       shift;                                          \
                   done;                                               \
                   msg=\"\$msg\$1 argument(s); \$args given.\";        \
                   bail \"\$msg\";                                     \
               };                                                      \
               for item; do                                            \
                   [ -z \"\${_$fn:++}\" ] || _$fn=\"\${_$fn} \";       \
                   while ipart=\${item%%\\'*}; do                      \
                       if case \${ipart} in                            \
                           *[!-+=~/:.0-9_a-zA-Z]*) false;;             \
                       esac then _$fn=\${_$fn:-}\${ipart};             \
                       else _$fn=\"\${_$fn:-}'\${ipart}'\";            \
                       fi;                                             \
                       [ \"\${item}\" = \"\${ipart}\" ] && break;      \
                       _$fn=\"\${_$fn:-}\\\\'\";                       \
                       item=\${item#*\\'};                             \
                   done;                                               \
               done;                                                   \
               i=\$#;                                                  \
               while [ \$i -lt $args ]; do                             \
                   _$fn=\"\${_$fn:-} ''\";                             \
                   i=\$((\$i + 1));                                    \
               done;                                                   \
               unset item ipart i;                                    \
           }"
    unset fn args
}


# Create DSL and default configuration
######################################
#              keyword  cmd      args         verbose_arg
create_cmd_dsl 'cp'     'cp'     '-al'        '--verbose'
create_cmd_dsl 'mv'     'mv'     '-T'         '--verbose'
create_cmd_dsl 'rm'     'rm'     '-rf'        '--verbose'
create_cmd_dsl 'mkdir'  'mkdir'  '-p -m 755'  '--verbose'
create_cmd_dsl 'rsync'  'rsync'  '-a --delete --numeric-ids --relative --delete-excluded' \
                                              '--verbose'
create_cmd_dsl 'date'   'date'   '-Iseconds'  ''
create_cmd_dsl 'touch'  'touch'  ''           ''
create_cmd_dsl 'ssh'    'ssh'    ''           '--verbose'

#                 keyword               default
create_scalar_dsl 'cmd_rsync_test_arg'  '--dry-run'
create_scalar_dsl 'backup_server'       ''
create_scalar_dsl 'snapshot_root'       "$(hostname)"
create_scalar_dsl 'loglevel'            0

#                 keyword     accepted # of args
create_array_dsl  'include'   1
create_array_dsl  'exclude'   1
create_array_dsl  'retain'    2
create_array_dsl  'backup'    2 3

# psnapshot script variables
############################
_command=
_configfile="/etc/psnapshot.conf"
_help=$PSNAPSHOT_FALSE
_test=$PSNAPSHOT_FALSE
_verbose=0
_version=$PSNAPSHOT_FALSE

# Parse the passed argument list.
#
# Args:
#   args: array of strings: The arguments to parse.
# Returns:
#   integer: success (TRUE/FALSE constant).
# Side effects:
#   Sets _command, _configfile, _help, _test, _verbose and _version.
parse_args() {
    while [ $# -gt 0 ]; do
	case "$1" in
	    --) shift; break;;
	    -c) if [ $# -eq 1 ] || [ "$2" = "--" ]; then
	            echo "No argument value for option -c"
		    return $PSNAPSHOT_FALSE
		else
		    _configfile="$2"
		    shift 2
		fi;;
	    -*) case "$1" in
	             -h*) _help=$PSNAPSHOT_TRUE;;
		     -t*) _test=$PSNAPSHOT_TRUE;;
                     -v*) _verbose=$(( $_verbose + 1 ));;
                     -V*) _version=$PSNAPSHOT_TRUE;;
	              -*) echo "Unknown option '-$(expr $1 : -\\\(.\\\))' while processing options"
		          return $PSNAPSHOT_FALSE;;
		esac
		opt=$(expr $1 : -.\\\(.*\\\))
                shift
	        set -- ${opt:+-$opt} $@
	        unset opt;;
	    *) break;;
        esac
    done

    if [ $# -gt 1 ]; then
        echo "To many commands given"
	return $PSNAPSHOT_FALSE
    fi
    
    _command=${1:-}
    return $PSNAPSHOT_TRUE
}


# Parse args & load configuration if we're not unit-testing
###########################################################
if [ -z ${SHUNIT_VERSION:-} ]; then
    error=eval parse_args $@
    [ $? -eq $PSNAPSHOT_TRUE ] || bail "$error"
    unset error

    # These functions should not be available in the configuration
    unset -f create_cmd_dsl create_scalar_dsl create_array_dsl parse_args

    # Version function do not need the configuration
    if [ $_version = $PSNAPSHOT_FALSE ]; then
        . $_configfile
    fi
fi


# Echos a message if the passed level is lower than the log level.
#
# Args:
#   level: integer: Log level to log the message with.
#   message: string: The message to log.
log() {
    if [ $1 -le $_loglevel ]; then 
        echo "$2"
    fi
}

# Convenience functions to log a message with a certain level.
#
# Args:
#   message: string: The message to log.
error()   { echo "$1" >&2;  }
info()    { log 1 "$1";	    }
message() { log 2 "  $1";   }
verbose() { log 3 "$1";     }
debug()   { log 4 "    $1"; }


# Show the version of the script.
#
# Args:
#   None
show_version() {
    echo "$(basename $0) $PSNAPSHOT_VERSION"
}

# Show the short usage string.
#
# Args:
#   None
show_usage() {
    echo "Usage: $(basename $0) [-c configfile] [-htvV] command";
}

# Show the commands as inserted by the configuration.
#
# Args:
#   None
show_commands() {
    eval set -- $_retain
    
    echo "Available commands:"
    while [ $# -gt 0 ]; do
        echo "    $1"
	shift 2
    done
}

# Show how to use the script.
#
# Args:
#   None
show_help() {
    show_version
    show_usage

    echo
    echo "psnapshot is a filesystem snapshot utility. It can take incremental"
    echo "snapshots of local filesystems to remote machines"
    echo
    echo "psnapshot comes with ABSOLUTELY NO WARRANTY.  This is free software,"
    echo "and you are welcome to redistribute it under certain conditions."
    echo "See the ISC License for details."
    echo
    echo "Options:"
    echo "    -c [file]  - Specify alternate config file (-c /path/to/file)."
    echo "    -h help    - Display this help".
    echo "    -v verbose - Increase verbosity level (maybe repeated)".
    echo "    -V version - Display the version."
    echo "    -t test    - Dry run."
    echo
    echo "Command:"
    echo "    retention  - Retention level as defined in the config file."
    echo
    
    show_commands
}

# Get the retention identifier for a specific retention index.
#
# Args:
#   index: number: The retention identifier to lookup
# Returns:
#   Echos the configured retention or none if not found.
retention() {
    i=$1
    i=$((i*2))
    eval set -- "$_retain"
    
    if [ $i -ge 0 ] && [ $i -lt $# ]; then
	shift $i
        echo "$1"
    fi
    
    unset i
}

# Get the number of history items to keep for a specific retention
# index.
#
# Args:
#   index: number: The retention identifier to lookup the history for
# Returns:
#   Echos the configured history items related to the specified retention.
#   If the index specifies a wrong rentention '-1' is echoed.
retention_history() {
    i=$1
    i=$((i*2+1))
    eval set -- "$_retain"
    
    if [ $i -lt 0 ] || [ $i -gt $# ]; then
        echo "-1"
    else
	shift $i
        echo $1
    fi
    
    unset i
}

# Get the index of the retention identifier.
#
# Args:
#   retention: string: The retention identifier to lookup
# Returns:
#   Echos the index back. If the retention identifier is not found
#   '-1' will be echoed.
retention_index() {
    retention=$1
    eval set -- "$_retain"
    
    i=0
    while [ $# -gt 0 ]; do
        if [ "$1" = "$retention" ]; then
	    echo "$i"
	    unset i retention
	    return
	fi
	i=$((i+1))
	shift 2
    done

    unset i retention
    echo "-1"
}


#function rremove {
#    local args="${_rm_args} $(verbose "$_rm_verbose_arg")"
#
#    message "Remove '$1'"
#    rexecute "if [[ -e \"$1\" ]]; then $_rm $args \"$1\"; else echo \"$(verbose "'$1' doesn't exist")\"; fi"
#}

#rrename {
#    local args="${_mv_args} $(verbose "$_mv_verbose_arg")"
#
#    message "Rename '$1' to '$2'"
#    rexecute "if [[ -e \"$1\" ]]; then $_mv $args \"$1\" \"$2\"; else echo \"$(verbose "'$1' doesn't exist")\"; fi"
#}

# Rotate the created backups from 0 up to the associated history.
#
# Args:
#   index: number: The retention identifier to rotate
# Returns:
#   None.
rotate() {
    retention=$(retention $1)
    history=$(retention_history $1)

    info "Rotating $retention backups"
    rremove "${_snapshot_root}/${retention}.$((--history))"
    while [ $history -gt 0 ]; do
        rrename "${_snapshot_root}/${retention}.$((--history))" "${_snapshot_root}/${retention}.$((history + 1))"
    done

    unset retention history
}

# Create a snapshot of the local client to a remote server.
#
# Args:
#   index: number: The retention identifier to create a snapshot for.
# Returns:
#   None
snapshot() {
    retention=$(retention $1)
    date=$2
    
    rcopy "${_snapshot_root}/${retention}.1" "${_snapshot_root}/${retention}.0"
    rmkdir "${_snapshot_root}/${retention}.0"

    eval set -- "$_backup"
    while [ $# -gt 0 ]; do
        synch "$1" "${_backup_server}:${_snapshot_root}/${retention}.0$2" "$3"
        shift 3
    done

    rtouch "${_snapshot_root}/${retention}.0" "${date}"

    unset retention
}

# Propagate the previous retention level up to the specified level.
#
# Args:
#   index: number: The retention identifier to rotate
# Returns:
#   None
propagate() {
    retention=$(retention $1)
    prev_retention=$(retention $(($1-1)))
    history=$(retention_history $(($1-1)))

    rrename "${_snapshot_root}/${prev_retention}.$((history - 1))" "${_snapshot_root}/${retention}.0"

    unset retention prev_retention history
}

# Backup the identified retention level.
#
# Args:
#   index: number: The retention identifier to rotate.
#   date: string: The date the backup is initiated.
# Returns:
#   None
archive() {
    if [ $1 = 0 ]; then
        snapshot $1 $2
    else
        propagate $1
    fi
}

# The scripts main method.
#
# Args:
#   None
# Returns:
#   None
main() {
    _retention_index=$(retention_index $_command)
    _date=$($_date_cmd)

    if [ $_help = $PSNAPSHOT_TRUE ]; then
        show_help;
	quit
    elif [ $_version = $PSNAPSHOT_TRUE ]; then
        show_version
	quit
    elif [ $_retention_index -eq -1 ]; then
        show_commands
	bail ""
    fi

    if [ $_verbose -gt 0 ]; then
        _loglevel=$_verbose
    fi

    info "Taking '${_command}' snapshot"
    rotate ${_retention_index}
    archive ${_retention_index} ${_date}
}

# Do not execute if we're testing
if [ -z ${SHUNIT_VERSION:-} ]; then
   main
fi


# Main script
########
#exit 0

: <<'EOF'


_date=$(date +%Y%m%d%H%M.%S)


function enable_test {
    if [[ $_test = 1 ]]; then
        echo "$1"
    fi
}

function flag_args {
    local prefix=$1
    shift 1
    for arg in $@; do
        echo "${prefix}${arg}"
    done
}

function args {
    if [[ "${1-}" != "-" ]]; then
        for arg in ${1-}; do
            echo "$arg"
        done
    fi
}

function enable_command_log {
    if ((5 <= $_verbosity)); then
        set -x
    fi
}

function rexecute {
    debug "Remotely execute: $1"
    if [[ $_test = 0 ]]; then
        local cmd=($_ssh)
        cmd+=($(args "${_ssh_args}"))
        cmd+=("${_backup_server}" "$@")
        if [ -e "/dev/pts/ptmx" -a -c "/dev/pts/ptmx"  ]; then
            ( enable_command_log; "${cmd[@]}" < /dev/pts/ptmx )
        else
            ( enable_command_log; "${cmd[@]}" )
        fi
    fi
}

function lexecute {
    local force=0
    if [[ -n "$1" && "$1" = "--force" ]]; then
        force=1
        shift 1
    fi

    debug "Locally execute: $*"
    if [[ $_test = 0 || $force=1 ]]; then
        ( enable_command_log; "$@" )
    fi
}

function rmkdir {
    local args="${_mkdir_args} $(verbose "$_mkdir_verbose_arg")"

    message "Make directory '$1'"
    rexecute "if [[ ! -e \"$1\" ]]; then $_mkdir $args \"$1\"; else echo \"$(verbose "'$1' already exist")\"; fi"
}


function rtouch {
    message "Set date of '$1' to '$2'"
    rexecute "if [[ -e \"$1\" ]]; then $_touch \"$1\" -t \"$2\"; else echo \"$(verbose "'$1' doesn't exist")\"; fi"
}

function rcopy {
    local args="${_cp_args} $(verbose "$_cp_verbose_arg")"

    message "Copy '$1' to '$2'"
    rexecute "if [[ -e \"$1\" ]]; then $_cp $args \"$1\" \"$2\"; else echo \"$(verbose "'$1' doesn't exist")\"; fi"
}

function synch {
    local extra_args="$(args "$3")"
    local opts=(--rsh="$_ssh $_ssh_args")
    opts+=($(args "${_rsync_args}"))
    opts+=($(args $(verbose "${_rsync_verbose_arg}")))
    opts+=($(args $(enable_test "$_rsync_test_arg")))
    opts+=($(flag_args "--include=" "${_include[@]-}"))
    opts+=($(flag_args "--exclude=" "${_exclude[@]-}"))
    opts+=($(args "$3"))
    opts+=($1 $2)

    message "Synchronize '$1' to '$2' $(test -z "$extra_args" || echo "using extra arguments '$extra_args'")"
    lexecute --force "$_rsync" "${opts[@]}"
}


EOF;
